# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `cliver` gem.
# Please instead update this file by running `bin/tapioca gem cliver`.

# Cliver is tool for making dependency assertions against
# command-line executables.
#
# source://cliver//lib/cliver/version.rb#3
module Cliver
  extend ::Cliver

  # Wraps Cliver::assert and returns truthy/false instead of raising
  #
  # @return [False, String] either returns false or the reason why the
  #   assertion was unmet.
  # @see Cliver::assert
  #
  # source://cliver//lib/cliver.rb#77
  def dependency_unmet?(*args, &block); end

  class << self
    # A legacy interface for {::detect} with the option `strict: true`, ensures
    # that the first executable on your path matches the requirements.
    #
    # @option options
    # @overload initialize
    # @param options [Hash] a customizable set of options
    # @raise [Cliver::Dependency::NotMet] if no match found
    # @return [String] path to an executable that meets the requirements
    # @see Cliver::Dependency
    #
    # source://cliver//lib/cliver.rb#46
    def assert(*args, &block); end

    # A non-raising variant of {::detect!}, simply returns false if dependency
    # cannot be found.
    #
    # @overload initialize
    # @return [see #detect!] or nil if no match found.
    # @see Cliver::Dependency
    #
    # source://cliver//lib/cliver.rb#34
    def detect(*args, &block); end

    # The primary interface for the Cliver gem allows detection of an executable
    # on your path that matches a version requirement, or raise an appropriate
    # exception to make resolution simple and straight-forward.
    #
    # @overload initialize
    # @raise [Cliver::Dependency::NotMet] if no match found
    # @return [String] path to an executable that meets the requirements
    # @see Cliver::Dependency
    #
    # source://cliver//lib/cliver.rb#23
    def detect!(*args, &block); end

    # Verify an absolute-path to an executable.
    #
    # @overload verify!
    #
    # source://cliver//lib/cliver.rb#59
    def verify!(executable, *args, &block); end
  end
end

# This is how a dependency is specified.
#
# source://cliver//lib/cliver/dependency.rb#7
class Cliver::Dependency
  # @overload initialize
  # @return [Dependency] a new instance of Dependency
  #
  # source://cliver//lib/cliver/dependency.rb#51
  def initialize(executables, *args, &detector); end

  # One of these things is not like the other ones...
  # Some feature combinations just aren't compatible. This method ensures
  # the the features selected for this object are compatible with each-other.
  #
  # @raise [ArgumentError] if incompatibility found
  # @return [void]
  #
  # source://cliver//lib/cliver/dependency.rb#69
  def check_compatibility!; end

  # The non-raise variant of {#detect!}
  #
  # @return [see #detect!] or nil if no match found.
  #
  # source://cliver//lib/cliver/dependency.rb#96
  def detect; end

  # Detects an installed version of the executable that matches the
  # requirements.
  #
  # @raise [Cliver::Dependency::NotMet] if no match found
  # @return [String] path to an executable that meets the requirements
  #
  # source://cliver//lib/cliver/dependency.rb#106
  def detect!; end

  # Get all the installed versions of the api-compatible executables.
  # If a block is given, it yields once per found executable, lazily.
  #
  # @return [Hash<String,String>] executable_path, version
  # @yieldparam executable_path [String]
  # @yieldparam version [String]
  # @yieldreturn [Boolean] - true if search should stop.
  #
  # source://cliver//lib/cliver/dependency.rb#83
  def installed_versions; end

  private

  # Given a path to an executable, detect its version
  #
  # @api private
  # @param executable_path [String]
  # @raise [ArgumentError] if version cannot be detected.
  # @return [String]
  #
  # source://cliver//lib/cliver/dependency.rb#186
  def detect_version(executable_path); end

  # @api private
  # @return [String] a plain-language representation of the executables
  #   for which we were searching
  #
  # source://cliver//lib/cliver/dependency.rb#160
  def executable_description; end

  # @api private
  # @return [Gem::Requirement]
  #
  # source://cliver//lib/cliver/dependency.rb#124
  def filtered_requirement; end

  # Analog of Windows `where` command, or a `which` that finds *all*
  # matching executables on the supplied path.
  #
  # @raise [ArgumentError]
  # @return [Enumerable<String>] - the executables found, lazily.
  #
  # source://cliver//lib/cliver/dependency.rb#199
  def find_executables; end

  # @api private
  # @raise [Cliver::Dependency::NotFound] with appropriate error message
  #
  # source://cliver//lib/cliver/dependency.rb#142
  def raise_not_found!; end

  # @api private
  # @param installed [Hash<String,String>] the found versions
  # @raise [Cliver::Dependency::VersionMismatch] with appropriate error message
  #
  # source://cliver//lib/cliver/dependency.rb#150
  def raise_version_mismatch!(installed); end

  # @api private
  # @param raw_version [String]
  # @return [Boolean]
  #
  # source://cliver//lib/cliver/dependency.rb#133
  def requirement_satisfied_by?(raw_version); end

  # @api private
  # @return [String] a plain-language representation of the requirements
  #
  # source://cliver//lib/cliver/dependency.rb#170
  def requirements_description; end

  # If strict? is true, only attempt the first matching executable on the path
  #
  # @api private
  # @return [Boolean]
  #
  # source://cliver//lib/cliver/dependency.rb#177
  def strict?; end
end

# An exception that is raised when executable is not present at all.
#
# source://cliver//lib/cliver/dependency.rb#17
class Cliver::Dependency::NotFound < ::Cliver::Dependency::NotMet; end

# An exception class raised when assertion is not met
#
# source://cliver//lib/cliver/dependency.rb#10
class Cliver::Dependency::NotMet < ::ArgumentError; end

# A pattern for extracting a {Gem::Version}-parsable version
#
# source://cliver//lib/cliver/dependency.rb#20
Cliver::Dependency::PARSABLE_GEM_VERSION = T.let(T.unsafe(nil), Regexp)

# An exception that is raised when executable present, but
# no version that matches the requirements is present.
#
# source://cliver//lib/cliver/dependency.rb#14
class Cliver::Dependency::VersionMismatch < ::Cliver::Dependency::NotMet; end

# Default implementation of the detector needed by Cliver::Assertion,
# which will take anything that #respond_to?(:to_proc)
#
# source://cliver//lib/cliver/detector.rb#10
class Cliver::Detector < ::Struct
  # Forgiving input, allows either argument if only one supplied.
  #
  # @overload initialize
  # @overload initialize
  # @overload initialize
  # @return [Detector] a new instance of Detector
  #
  # source://cliver//lib/cliver/detector.rb#32
  def initialize(*args); end

  # The argument to pass to the executable to get current version
  # Defaults to {DEFAULT_COMMAND_ARG}
  #
  # @return [String, Array<String>]
  #
  # source://cliver//lib/cliver/detector.rb#74
  def command_arg; end

  # @param executable_path [String] - the path to the executable to test
  # @return [String] - should be contain {Gem::Version}-parsable
  #   version number.
  #
  # source://cliver//lib/cliver/detector.rb#42
  def detect_version(executable_path); end

  # This is the interface that any detector must have.
  # If not overridden, returns a proc that wraps #detect_version
  #
  # @return [Proc] following method signature of {#detect_version}
  # @see #detect_version
  #
  # source://cliver//lib/cliver/detector.rb#58
  def to_proc; end

  # @param executable_path [String] the executable to test
  # @return [Array<String>]
  #
  # source://cliver//lib/cliver/detector.rb#80
  def version_command(executable_path); end

  # The pattern to match the version in {#version_command}'s output.
  # Defaults to {DEFAULT_VERSION_PATTERN}
  #
  # @return [Regexp] - the pattern used against the output
  #   of the #version_command, which should
  #   contain a {Gem::Version}-parsable substring.
  #
  # source://cliver//lib/cliver/detector.rb#67
  def version_pattern; end

  class << self
    # @param detector_argument [#call, Object] If detector_argument responds to #call, return it; otherwise attempt
    #   to create an instance of self.
    #
    # source://cliver//lib/cliver/detector.rb#11
    def generate(detector_argument); end
  end
end

# Default command argument to use against the executable to get
# version output
#
# source://cliver//lib/cliver/detector.rb#21
Cliver::Detector::DEFAULT_COMMAND_ARG = T.let(T.unsafe(nil), String)

# Default pattern to use when searching {#version_command} output
#
# source://cliver//lib/cliver/detector.rb#17
Cliver::Detector::DEFAULT_VERSION_PATTERN = T.let(T.unsafe(nil), Regexp)

# A Namespace to hold filter procs
#
# source://cliver//lib/cliver/filter.rb#5
module Cliver::Filter
  # Apply to some input
  #
  # @param version [String]
  # @return [String]
  #
  # source://cliver//lib/cliver/filter.rb#24
  def apply(version); end

  # Apply to a list of requirements
  #
  # @param requirements [Array<String>]
  # @return [Array<String>]
  #
  # source://cliver//lib/cliver/filter.rb#12
  def requirements(requirements); end
end

# The identity filter returns its input unchanged.
#
# source://cliver//lib/cliver/filter.rb#7
Cliver::Filter::IDENTITY = T.let(T.unsafe(nil), Proc)

# source://cliver//lib/cliver/shell_capture.rb#4
class Cliver::ShellCapture
  # @overload initialize
  # @return [void]
  #
  # source://cliver//lib/cliver/shell_capture.rb#13
  def initialize(command); end

  # Returns the value of attribute command_found.
  #
  # source://cliver//lib/cliver/shell_capture.rb#5
  def command_found; end

  # Returns the value of attribute stderr.
  #
  # source://cliver//lib/cliver/shell_capture.rb#5
  def stderr; end

  # Returns the value of attribute stdout.
  #
  # source://cliver//lib/cliver/shell_capture.rb#5
  def stdout; end
end

# Cliver follows {http://semver.org SemVer}
#
# source://cliver//lib/cliver/version.rb#5
Cliver::VERSION = T.let(T.unsafe(nil), String)

# Core-Extensions on File
#
# source://cliver//lib/core_ext/file.rb#4
class File < ::IO
  class << self
    # determine whether a String path is absolute.
    #
    # @example
    #   File.absolute_path?('foo') #=> false
    #   File.absolute_path?('/foo') #=> true
    #   File.absolute_path?('foo/bar') #=> false
    #   File.absolute_path?('/foo/bar') #=> true
    #   File.absolute_path?('C:foo/bar') #=> false
    #   File.absolute_path?('C:/foo/bar') #=> true
    # @param path [String] - a pathname
    # @return [Boolean]
    #
    # source://cliver//lib/core_ext/file.rb#15
    def absolute_path?(path, platform = T.unsafe(nil)); end
  end
end

# source://cliver//lib/core_ext/file.rb#37
File::ABSOLUTE_PATH_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://cliver//lib/core_ext/file.rb#27
File::POSIX_ABSOLUTE_PATH_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://yard/0.9.28/lib/yard/core_ext/file.rb#5
File::RELATIVE_PARENTDIR = T.let(T.unsafe(nil), String)

# source://yard/0.9.28/lib/yard/core_ext/file.rb#6
File::RELATIVE_SAMEDIR = T.let(T.unsafe(nil), String)

# source://cliver//lib/core_ext/file.rb#31
File::WINDOWS_ABSOLUTE_PATH_PATTERN = T.let(T.unsafe(nil), Regexp)
